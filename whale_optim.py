# -*- coding: utf-8 -*-
"""Whale_optim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18Sj6_rra_6b7f2FrRvvjCRAhfP-fk1qs
"""

import random
import numpy as np

# Define the objective function to minimize
def objective_function(x, y):
    return x**2 + np.cos(y) + y**2

# Define the constraint function
def constraint(x, y):
    return x**2 + y**2 < 2

# WOA parameters
max_generations = 100
population_size = 50
dimension = 2  # Two dimensions for (x, y)
a = 2.0
A = 2.0
rand = np.random.rand

# Initialize the population within the constraint
population = [np.random.uniform(-np.sqrt(2), np.sqrt(2), dimension) for _ in range(population_size)]
for i in range(population_size):
    while not constraint(*population[i]):
        population[i] = np.random.uniform(-np.sqrt(2), np.sqrt(2), dimension)

fitness_values = [objective_function(*individual) for individual in population]

for generation in range(max_generations):
    for i in range(population_size):
        a_linear = 2 - generation * (2 / max_generations)

        curr_best_idx = np.argmin(fitness_values)
        if rand() < 0.5:
            # D = np.abs(A * np.random.uniform(0, 1, dimension) - population[i])
            # population[i] = D * np.exp(a_linear) * np.cos(2 * np.pi * rand()) + population[i]
            D = np.abs(A*np.random.uniform(0,1,dimension)*population[curr_best_idx] - population[i])
            population[i] = population[curr_best_idx] - A*D
        else:
            distance_leader = np.abs(population[i] - population[np.argmin(fitness_values)])
            population[i] = distance_leader * np.exp(a_linear) * np.cos(2 * np.pi * rand()) + population[i]

        # Ensure individuals stay within the constraint
        while not constraint(*population[i]):
            population[i] = np.random.uniform(-np.sqrt(2), np.sqrt(2), dimension)

        fitness_values[i] = objective_function(*population[i])

    best_index = np.argmin(fitness_values)
    best_solution = population[best_index]
    best_fitness = fitness_values[best_index]

    print(f"Generation {generation+1}/{max_generations}: Best Fitness = {best_fitness}")

print("Optimal Solution:")
print("Best Position (x, y):", best_solution)
print("Best Fitness:", best_fitness)

